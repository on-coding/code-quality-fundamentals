{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>There is no set of rules for making the right decision, there are always tradeoffs that we must weigh up. However there are principles that it is helpful to be aware of.</p> <p>This guide is intended as a concise explanation of common code quality principles. </p>"},{"location":"#what-is-code-quality","title":"What is code quality?","text":"<p>Code quality is all about delivering the most value over the life span of a project.</p> <p>The qualities of a good codebase are:</p> <ul> <li>Correctness - The software does what it is supposed to do</li> <li>Evolvability - We can add new features or change existing features quickly</li> <li>Maintainability - We don't have to spend much time maintaining the existing functionality</li> </ul> <p>You will come across the sentiment of \"We should be spending time on delivering value to users not on code quality\". Although it's certainly true that we shouldn't spend too much time trying to make our code perfect, in general this is a false dichotomy since:</p> <ul> <li>Code quality helps, not hinders, delivering value quickly.</li> <li>Most of the time writing good code doesn't take much longer than bad code.</li> </ul> <p>The impact of poor code quality can be quite extreme, I've worked on projects where new features that should have taken a day consistently took weeks due to issues with the codebase.</p>"},{"location":"#the-principles-work-in-progress","title":"The principles (work in progress)","text":"<ul> <li>DRY</li> <li>...</li> </ul>"},{"location":"principles/dry/","title":"DRY","text":""},{"location":"principles/dry/#what-is-dry","title":"What is DRY","text":"<p>DRY stands for \"Don't Repeat Yourself\". It's a principle that roughly says that we should avoid duplication.</p> <p>Most developers intuitively understand that repeating the same block of code multiple times in our code base is a bad idea, but what exactly is the problem?</p>"},{"location":"principles/dry/#problems","title":"Problems","text":"<ul> <li>Bugs and Inconsistencies</li> </ul> <p>There's a risk that someone will accidentally change the logic in one place but forget to update the same logic elsewhere</p> <ul> <li>Making changes will take longer</li> </ul> <p>It will take a bit longer to type out changes because we have to make them in multiple places. However that's a small issue compared to how much longer   it will take us to reason about what changes to make in the first place. We're likely to spend time:</p> <ul> <li>tracking down all the places where the logic is used</li> <li>understanding the current implementation for each one, since they may be slightly different</li> <li>figuring out the right change in each case</li> </ul>"},{"location":"principles/dry/#what-is-duplication","title":"What is duplication","text":"<p>We can see that these problems apply more widely than just when lines of code are repeated. As a simple example, we could implement that exact same functionality twice but without any lines of code in common. But we can still hit the problems above even if each piece of functionality is only implemented once.</p> <p>The more general principle is</p> <p>We should avoid depending on the same choice in multiple different places</p> <p>Here \"choice\" means any decision about the functionality our software supports or how that functionality is implemented. These choices don't have to have been made by us, for instance they could come from a product team or an upstream system.</p> <p>If we did have code that depends on particular choice scattered throughout our system, then if that choice were to change we would hit the same problems described above.</p> <p>To give a couple of examples:</p>"},{"location":"principles/dry/#example-1","title":"Example 1","text":"<ul> <li>We need to be able to quickly find items in a list of names, so we choose to keep the list sorted.</li> <li>In one part of the codebase we have a function that inserts items into the list, ensuring the list remains sorted.</li> <li>In another part of the codebase we have a function the finds an item in the list, assuming that the list is already sorted.</li> </ul>"},{"location":"principles/dry/#example-2","title":"Example 2","text":"<ul> <li>We need to store data about a customers order. We choose to store it in a csv file with the column order being (item, price, quantity)</li> <li>In one part of the codebase we write the csv file with column order (item, price, quantity)</li> <li>In another part of the codebase we read the csv file, assuming the column order is (item, price, quantity)</li> </ul> <p>In both examples there is no duplication of the functionality, but there are multiple places where the logic relies on the same underlying choice about how the data is structured.</p> <p>In both cases the solution is to move the two functions next to each other in the code base. Although there is still some duplication, the associated problems are greatly reduced because they are contained to a single file rather than the whole codebase.</p> <p>Often we won't be able to completely remove duplication but we can still manage it by limiting it to a specific part of the codebase. This idea ties into other principles such as \"Encapsulation\" and \"Separation of Concerns\", which will be covered in other articles.</p>"},{"location":"principles/dry/#tradeoffs","title":"Tradeoffs","text":""},{"location":"principles/dry/#generalization-complexity","title":"Generalization complexity","text":"<p>Sometimes each use case of the same logic is different enough that extracting the shared part is quite difficult. It might create more complexity to implement the general case rather than having a different implementation for each case.</p>"},{"location":"principles/dry/#over-generalization","title":"Over-generalization","text":"<p>Sometimes code is only \"coincidentally\" that same rather than logically representing the same thing. For example you may have two types, one that represents the user input for an order, and one that represents an order as it is stored in the database. They might currently have all the same fields, however logically they represent different things and will likely deviate overtime.</p>"},{"location":"principles/dry/#difficulty-of-updating-shared-functionality","title":"Difficulty of updating shared functionality","text":"<p>If multiple functions call the same function, and then any changes to that API for that shared function will require updating all of the callers. This might be reasonable if the code is all in a single repository, however if the function is part of a shared library then this will be more difficult.</p>"},{"location":"principles/dry/#code-examples","title":"Code Examples","text":""},{"location":"principles/dry/#repeated-lines-of-code","title":"Repeated lines of code","text":"<p>This is a simple case where two functions implement very similar logic. The solution is to pull out the common part of the logic into a shared function.</p> With duplication<pre><code>def total_book_value(orders: List[Order]):\n    return sum(\n        order.price * order.quantity\n        for order in orders\n        if order.category == \"book\"\n    )\n\n\ndef total_grocery_value(orders: List[Order]):\n    return sum(\n        order.price * order.quantity\n        for order in orders\n        if order.category == \"grocery\"\n    )\n</code></pre> Fixed<pre><code>def total_value_by_category(orders: List[Order], category: str) -&gt; int:\n    return sum(\n        order.price * order.quantity\n        for order in orders\n        if order.category == category\n    )\n\n\ndef total_book_value(orders: List[Order]) -&gt; int:\n    return total_value_by_category(orders, \"book\")\n\n\ndef total_grocery_value(orders: List[Order]) -&gt; int:\n    return total_value_by_category(orders, \"grocery\")\n</code></pre>"},{"location":"principles/dry/#repeated-constants","title":"Repeated constants","text":"<p>The problem here is that two different functions assume <code>book</code> is spelt in a certain way, i.e. <code>book</code> rather than <code>Book</code>. In general these constants are called \"Magic strings\" and they can be replaced by named constants. In this case there are multiple categories so we could also use an enum.</p> With duplication<pre><code>def total_book_value(orders: List[Order]) -&gt; int:\n    return total_value_by_category(orders, \"book\")\n\n\ndef create_book_order(price: int, quantity: int) -&gt; Order:\n    return Order(price, quantity, \"book\")\n</code></pre> Fixed<pre><code>class Category(enum.Enum):\n    BOOK = \"book\"\n    GROCERY = \"grocery\"\n\n\ndef total_book_value(orders: List[Order]) -&gt; int:\n    return total_value_by_category(orders, Category.BOOK)\n\n\ndef create_book_order(price: int, quantity: int) -&gt; Order:\n    return Order(price, quantity, Category.BOOK)\n</code></pre>"},{"location":"principles/dry/#duplicated-storage-format-dependency","title":"Duplicated storage format dependency","text":"<p>With duplication:</p> save_orders.py<pre><code>def save_orders(orders: List[Order]) -&gt; None:\n    with open(\"orders.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        for order in orders:\n            writer.writerow((order.item, order.price, order.quantity))\n</code></pre> total_value.py<pre><code>def total_value() -&gt; int:\n    total = 0\n    with open(\"orders.csv\", \"r\") as f:\n        reader = csv.reader(f)\n        for row in reader:\n            item, price, quantity = row\n            total += price * quantity\n    return total\n</code></pre> <p>Fixed:</p> order_storage.py<pre><code>ORDER_FILENAME = \"order.csv\"\n\ndef save_orders(orders: List[Order]) -&gt; None:\n    with open(ORDER_FILENAME, \"w\") as f:\n        writer = csv.writer(f)\n        for order in orders:\n            writer.writerow((order.item, order.price, order.quantity))\n\n\ndef read_order() -&gt; List[Order]:\n    results: List[Order] = []\n    with open(ORDER_FILENAME, \"r\") as f:\n        reader = csv.reader(f)\n        for row in reader:\n            item, price, quantity = row\n            results.append(Order(item, price, quantity))\n    return results\n</code></pre> total_value.py<pre><code>def total_value() -&gt; int\n    orders = read_orders()\n    return sum(order.price * order.quantity for order in orders)\n</code></pre>"}]}